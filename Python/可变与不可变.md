## Fluent Python

可变/不可变类型,指的是：内存id不变，type也不变的前提下，value是否是可变的。
int（）和str（）都是不可变类型，元组是不可变的
列表、字典，集合是可变类型

每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理 解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标识的 整数表示。

== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。

在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别

```python
当传入对象是可变对象时，应该创建对象的副本，而不是直接赋值（相当于别名），否则会直接影响对象的值
l2 = l1 # 赋值 对象地址是一样的
创建副本：例如对于列表l1
l2 = list(l1)
#or
l2 = copy.copy(l1) # id(l1), id(l2) different 拷贝出来的新对象的地址和原对象是不一样的
#or deepcooy
l2 = copy.deepcopy(l1)
```




del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删 除的变量保存的是对象的最后一个引用，或者无法得到对象时。 2 重新绑定也可能会导致 对象的引用数量归零，导致对象被销毁。

在 CPython 中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少 引用指向自己。当引用计数归零时，对象立即就被销毁：CPython 会在对象上调用` __del__ `方法（如果定义了），然后释放分配给对象的内存。CPython　2.0 增加了分代垃 圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即 使再出色的引用方式也会导致组中的对象不可获取。

　Python的私有属性和“受保护的”属性

为了避免这种情况，如果以 `__mood` 的形式（两个前导下划线，尾部没有或最多有一个下 划线）命名实例属性，Python 会把属性名存入实例的 `__dict__ `属性中，而且会在前面加 上一个下划线和类名。因此，对 Dog 类来说，`__mood `会变成 `_Dog__mood`；对 Beagle 类来说，会变成 `_Beagle__mood`。这个语言特性叫名称改写（name mangling）。