## Java问题



- Java的堆和栈的区别
  在Java中，内存分为两种，一种是栈内存，另一种是堆内存
  1.堆内存用来存放由new创建的对象和数组。
  2.栈内存用来存放方法或者局部变量等
  3.堆是先进先出，后进后出
  4.栈是后进先出，先进后出

- Java的GC垃圾回收机制

  垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制

**分代收集算法**：将堆分为新生代和老年代，新生代存活率低用**复制算法**，老年代存活率高用 **标记清除或标记整理算法**； HotSpot 虚拟机，新生代分为 `Eden - survivor_from - survivor_to（8:1:1）`，Eden 区一次 MinorGC 仍存活复制到 survivor 区，survivor 区每次 GC 年龄加 1，两块之间不停复制，年 龄到达阈值的移动到老年代。大对象直接进入老年代。 MinorGC 回收新生代，频繁；FullGC 回收老年代和新生代。GC 时分析对象引用关系时停顿 所有线程，称为 `stop the world `

垃圾收集器： 新生代：Serial 单线程，client 场景默认；ParNew 多线程，可配合 CMS，server 场景默认； Parallel Scavenge 多线程，吞吐量优先，适合后台运算。 老年代：Serial Old，Serial 的老年代版本；Parallel Old，Parallel Scavenge 的老年代版本； CMS，初始标记、并发标记、重新标记、并发清除，并发时不停顿。 G1：面向服务端应用的垃圾收集器，将堆划分成多个独立区域单独进行垃圾回收 。初始标 记、并发标记、最终标记、筛选回收。空间整合，整体标记整理，局部复制；可预测停顿， 维护优先列表，根据允许时间优先回收价值最大的区域

这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。
判断对象是否可被回收：引用计数算法-循环引用无法回收、可达性分析算法；

CMS(Concurrent Mark Sweep)：以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现
优点:
并发，低停顿
缺点：
1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢. 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高
2、无法处理浮动垃圾：在最后一步并发清理过程中，用户线程执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉，这部分垃圾叫浮动垃圾
3、CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，将会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC，为了解决这个问题CMS提供了一个开关参数，用于在CMS顶不住，要进行FullGC时开启内存碎片的合并整理过程，但是内存整理的过程是无法并发的，空间碎片没有了但是停顿时间变长了

G1：是一款面向服务端应用的垃圾收集器
特点：
1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
2、分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。
3、空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。
4、可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。



- 什么是多态

Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)

Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。（或抽象类）

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

1. 抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

- MVC模式与MVP模式

MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。
 在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的改变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。
 虽然 MVC 中的 View 的确“可以”访问 Model，但是我们不建议在 View 中依赖 Model，而是要求尽可能把所有业务逻辑都放在 Controller 中处理，而 View 只和 Controller 交互。

MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版

mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding):   View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作，框架已经帮你做好了。



- String、StringBuffer、StringBuilder的区别

在拼接字符串过程中，使用StringBuffer对象，而不使用String对象。这是因为String是不可变的对象，在每一次改变字符串时都会创建一个新的String对象；而StringBuffer则是可变的字符序列，类似于String的字符串缓冲区。所以，在字符串经常修改的地方使用StringBuffer，其效率将高于String。
在这方面运行速度快慢为：StringBuilder > StringBuffer > String。
线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。

- JDK（java development kit）
  JDK是Java开发工具包，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。
  JRE（ java runtime environment）
  JRE是java的运行环境，包含JVM标准实现及Java核心类库。
  JVM（java virtual machine）
  JVM是java虚拟机，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。

三者的关系
JDK=JRE+其他
JRE=JVM+其他



- 强引用：被强引用关联的对象不会被回收。

```java
Object obj = new Object();
```

- 软引用: 被软引用关联的对象只有在内存不够的情况下才会被回收。

```java
// 使用 SoftReference 类来创建软引用
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

- 弱引用: 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
  使用 WeakReference 类来创建弱引用。

  ```java
  Object obj = new Object();
  WeakReference<Object> wf = new WeakReference<Object>(obj);
  obj = null;
  ```

4. 虚引用: 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知



**volatile关键字的如何保证内存可见性**
volatile修饰的变量保证其每个写操作后都更新到主内存，每个读操作都到主内存中更新，具体的话是在JVM层面，在修饰的变量前后加关键字
顺带一提volatile还能防止指令重排，这两者的实现方式都是内存屏障
transient 关键字可以使一些属性不会被序列化